// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package product

import (
	"sync"
	"waiter/domain/product/entities"
)

// Ensure, that ProductRepositoryMock does implement ProductRepository.
// If this is not the case, regenerate this file with moq.
//var _ ProductRepository = &ProductRepositoryMock{}

// ProductRepositoryMock is a mock implementation of ProductRepository.
//
//	func TestSomethingThatUsesProductRepository(t *testing.T) {
//
//		// make and configure a mocked ProductRepository
//		mockedProductRepository := &ProductRepositoryMock{
//			AddFunc: func(product *entities.Product) error {
//				panic("mock out the Add method")
//			},
//			EditFunc: func(product *entities.Product) error {
//				panic("mock out the Edit method")
//			},
//			GetFunc: func(uuid string) (*entities.Product, error) {
//				panic("mock out the Get method")
//			},
//			GetAllFunc: func() ([]*entities.Product, error) {
//				panic("mock out the GetAll method")
//			},
//			GetByCodeFunc: func(code string) (*entities.Product, error) {
//				panic("mock out the GetByCode method")
//			},
//			GetByNameFunc: func(name string) ([]*entities.Product, error) {
//				panic("mock out the GetByName method")
//			},
//		}
//
//		// use mockedProductRepository in code that requires ProductRepository
//		// and then make assertions.
//
//	}
type ProductRepositoryMock struct {
	// AddFunc mocks the Add method.
	AddFunc func(product *entities.Product) error

	// EditFunc mocks the Edit method.
	EditFunc func(product *entities.Product) error

	// GetFunc mocks the Get method.
	GetFunc func(uuid string) (*entities.Product, error)

	// GetAllFunc mocks the GetAll method.
	GetAllFunc func() ([]*entities.Product, error)

	// GetByCodeFunc mocks the GetByCode method.
	GetByCodeFunc func(code string) (*entities.Product, error)

	// GetByNameFunc mocks the GetByName method.
	GetByNameFunc func(name string) ([]*entities.Product, error)

	// calls tracks calls to the methods.
	calls struct {
		// Add holds details about calls to the Add method.
		Add []struct {
			// Product is the product argument value.
			Product *entities.Product
		}
		// Edit holds details about calls to the Edit method.
		Edit []struct {
			// Product is the product argument value.
			Product *entities.Product
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// UUID is the uuid argument value.
			UUID string
		}
		// GetAll holds details about calls to the GetAll method.
		GetAll []struct {
		}
		// GetByCode holds details about calls to the GetByCode method.
		GetByCode []struct {
			// Code is the code argument value.
			Code string
		}
		// GetByName holds details about calls to the GetByName method.
		GetByName []struct {
			// Name is the name argument value.
			Name string
		}
	}
	lockAdd       sync.RWMutex
	lockEdit      sync.RWMutex
	lockGet       sync.RWMutex
	lockGetAll    sync.RWMutex
	lockGetByCode sync.RWMutex
	lockGetByName sync.RWMutex
}

// Add calls AddFunc.
func (mock *ProductRepositoryMock) Add(product *entities.Product) error {
	if mock.AddFunc == nil {
		panic("ProductRepositoryMock.AddFunc: method is nil but ProductRepository.Add was just called")
	}
	callInfo := struct {
		Product *entities.Product
	}{
		Product: product,
	}
	mock.lockAdd.Lock()
	mock.calls.Add = append(mock.calls.Add, callInfo)
	mock.lockAdd.Unlock()
	return mock.AddFunc(product)
}

// AddCalls gets all the calls that were made to Add.
// Check the length with:
//
//	len(mockedProductRepository.AddCalls())
func (mock *ProductRepositoryMock) AddCalls() []struct {
	Product *entities.Product
} {
	var calls []struct {
		Product *entities.Product
	}
	mock.lockAdd.RLock()
	calls = mock.calls.Add
	mock.lockAdd.RUnlock()
	return calls
}

// Edit calls EditFunc.
func (mock *ProductRepositoryMock) Edit(product *entities.Product) error {
	if mock.EditFunc == nil {
		panic("ProductRepositoryMock.EditFunc: method is nil but ProductRepository.Edit was just called")
	}
	callInfo := struct {
		Product *entities.Product
	}{
		Product: product,
	}
	mock.lockEdit.Lock()
	mock.calls.Edit = append(mock.calls.Edit, callInfo)
	mock.lockEdit.Unlock()
	return mock.EditFunc(product)
}

// EditCalls gets all the calls that were made to Edit.
// Check the length with:
//
//	len(mockedProductRepository.EditCalls())
func (mock *ProductRepositoryMock) EditCalls() []struct {
	Product *entities.Product
} {
	var calls []struct {
		Product *entities.Product
	}
	mock.lockEdit.RLock()
	calls = mock.calls.Edit
	mock.lockEdit.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *ProductRepositoryMock) Get(uuid string) (*entities.Product, error) {
	if mock.GetFunc == nil {
		panic("ProductRepositoryMock.GetFunc: method is nil but ProductRepository.Get was just called")
	}
	callInfo := struct {
		UUID string
	}{
		UUID: uuid,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(uuid)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedProductRepository.GetCalls())
func (mock *ProductRepositoryMock) GetCalls() []struct {
	UUID string
} {
	var calls []struct {
		UUID string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// GetAll calls GetAllFunc.
func (mock *ProductRepositoryMock) GetAll() ([]*entities.Product, error) {
	if mock.GetAllFunc == nil {
		panic("ProductRepositoryMock.GetAllFunc: method is nil but ProductRepository.GetAll was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetAll.Lock()
	mock.calls.GetAll = append(mock.calls.GetAll, callInfo)
	mock.lockGetAll.Unlock()
	return mock.GetAllFunc()
}

// GetAllCalls gets all the calls that were made to GetAll.
// Check the length with:
//
//	len(mockedProductRepository.GetAllCalls())
func (mock *ProductRepositoryMock) GetAllCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetAll.RLock()
	calls = mock.calls.GetAll
	mock.lockGetAll.RUnlock()
	return calls
}

// GetByCode calls GetByCodeFunc.
func (mock *ProductRepositoryMock) GetByCode(code string) (*entities.Product, error) {
	if mock.GetByCodeFunc == nil {
		panic("ProductRepositoryMock.GetByCodeFunc: method is nil but ProductRepository.GetByCode was just called")
	}
	callInfo := struct {
		Code string
	}{
		Code: code,
	}
	mock.lockGetByCode.Lock()
	mock.calls.GetByCode = append(mock.calls.GetByCode, callInfo)
	mock.lockGetByCode.Unlock()
	return mock.GetByCodeFunc(code)
}

// GetByCodeCalls gets all the calls that were made to GetByCode.
// Check the length with:
//
//	len(mockedProductRepository.GetByCodeCalls())
func (mock *ProductRepositoryMock) GetByCodeCalls() []struct {
	Code string
} {
	var calls []struct {
		Code string
	}
	mock.lockGetByCode.RLock()
	calls = mock.calls.GetByCode
	mock.lockGetByCode.RUnlock()
	return calls
}

// GetByName calls GetByNameFunc.
func (mock *ProductRepositoryMock) GetByName(name string) ([]*entities.Product, error) {
	if mock.GetByNameFunc == nil {
		panic("ProductRepositoryMock.GetByNameFunc: method is nil but ProductRepository.GetByName was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockGetByName.Lock()
	mock.calls.GetByName = append(mock.calls.GetByName, callInfo)
	mock.lockGetByName.Unlock()
	return mock.GetByNameFunc(name)
}

// GetByNameCalls gets all the calls that were made to GetByName.
// Check the length with:
//
//	len(mockedProductRepository.GetByNameCalls())
func (mock *ProductRepositoryMock) GetByNameCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockGetByName.RLock()
	calls = mock.calls.GetByName
	mock.lockGetByName.RUnlock()
	return calls
}
